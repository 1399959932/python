#!C:/Users/JK-chenxs/AppData/Local/Programs/Python
# print('hello,world')

# 格式化字符串就是统一规范字符串

# format()
# 	 位置参数:
# 		'{0} love {1}.{2}'.format('i','my','anything')
# 	 关键字参数:
# 		'{0} love {a}.{c}'.format('I',a='my',c='family')
# 		注意单位置参数与关键字参数结合使用的时候,位置参数必须在管之间参数前面,否则会报错
#':' 是表示格式化符号的开始
	# '%c' 格式化字符
	# 	'%c' % 97
	# '%s' 格式化字符串
	# 	'%s' % 'i love you'
	# '%d' 格式化整数
	# 	'%d + %d = %d' % (41, 45, 41 + 45)
	# '%o' 格式化无符号八进制数
	# 	'%o' % 8
	# '%x' 格式化无符号十六进制数
	# 	'%x' % 16
	# '%X' 格式化无符号十六进大写

	# '%f' 格式化定点数(近似浮点数),可指定小数点后的精度,默认为6
	# 	'%f' % 16
	# '%e' 用科学计数法格式化定点数

	# '%E' 用科学计数法格式化定点数

	# '%g' 根据值得大小决定适中%f或者%e

	# '%G' 根据值得大小决定适中%f或者%e

# 十进制:每到0进一位
# 八进制:到8进一位
# 十六进制:a = 10, b = 11, c = 12, 16 = 0

# 格式化操作符辅助指令
	# 'm.n' ~ 'm是显示的最小总宽度(0可以不写即'.n'),n是小数点后的位数'
	# '-' ~ 用于左对齐
	# '+' ~ 在增速前面显示加号( + )
	# '#' ~ 在八进制数前边显示o(' o' ),在十六进制数面前显示' ox'或' 0X'
	# 	'%#o' % 13
	# '0' ~ 显示的数字前面填充' 0'取代空格
	# 	'%-06d' % 5

# 字符串转义字符
	# \'	单引号
	# \"	双引号
	# \a 	发出系统响铃声(并不会他会打印A码)
	# \b	退格符
	# \n 	换行符
	# \t 	横向制表符(TAB)
	# \v	纵向制表符
	# \r	回车符
	# \f 	换页符
	# \o 	八进制数代表的字符
	# \x 	16进制代表的字符
	# \0	表示一个控制符
	# \\	反斜杠

# 序列
# 列表list[],元祖tuple(),字符串string'',共同点:
	# 1.都可以通过索引得到每一个元素,索引默认为0
	# 2.可以通过分片的方法得到一个范围内元素的集合
	# 3.拥有共同的操作符	
	# 	'*'	重复操作符
	# 	'+'	拼接操作符
	# 	'in/not in' 成员关系操作符

# list() 把一个可迭代对象转换为列表
# 迭代:重复反馈过程的活动,为了接近或者达到目标,每一次对过程重复作为迭代
# 	每一次重复得到的结果都会作为下一次迭代的初始值
	# c = (1, 1, 2, 3, 5, 8, 13, 21, 34)

# tuple() 把一个可迭代对象转换为元祖
# len() 返回涨肚
# max() 返回序列,参数集合中的最大值(数据类型需要相同)
# min()	同上返回最小
	# 实现原理:
	# min = a[0]

	# for each in a:
	# 	if each < min:
	# 		min = each

	# return min
# sum(iterable[, start=0]) 返回序列iterable和可选参数start的综合
# 	sum(a, 1) 当 a = 1 返回 2
# sorted() 从小到大排列
# reversed() 逆转排列,返回迭代器对象
# 	套用list函数即可实现:list(reversed())
# enumerate() 同reversed,返回对象,使用list即可
# 	返回一个索引与元祖组成的元祖
# zip(a, b...) 返回由各个参数的元素组成的元祖.返回个数为所有相同索引个数


# 函数:
	# 创建函数'def func():'
				# 代码块
	# def func():
	# 	print('this is my function')
	# 	print('首字母忘记大写了')
	# 	print('关键字是def哦')

	# 调用函数'func()' , '函数名字()'
	# 原理:python向上寻找函数,并执行代码块,如果没有则报错

# 带参数的函数
	# def add(num1, num2):
	# 	result = num1 + num2
	# 	print(result)


# 循环
	# for...in循环，依次把list或tuple中的每个元素迭代出来
	# for x in []:
	# 	循环体
	# 	print()

# range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数：
	# 计算1到101的和
	# add = 0
	# for x in range(102):
	# 	add = x + add
	# 	print(add)	

# while循环，只要条件满足，就不断循环，条件不满足时退出循环。break语句可以提前退出循环
# 比如我们要计算100以内所有奇数之和，
	# sum = 0
	# n = 100
	# while n > 0:
	# 	sum = sum + n
	# 	n = n - 2
	# print(sum)

# break
	# n = 1
	# while n <= 100:
 #    	if n > 10: # 当n = 11时，条件满足，执行break语句
 #        break # break语句会结束当前循环
 #    	print(n)
 #    n = n + 1
	# print('END')

# continue
	# 在循环过程中通过continue语句，跳过当前的这次循环，直接开始下一次循环
	# n = 0
	# while n < 10:
 #    	n = n + 1
 #    	if n % 2 == 0: # 如果n是偶数，执行continue语句
 #        	continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行
 #    print(n)

 # break,continue 两个语句通常都必须配合if语句使用。


 dict{'key':value, '': ,}
 	# python内置的指点,在其他语言也称作map
 	# 我个人理解成php的数组键值对,键名=>键值,
 	# dict的key必须是不可变对象。	*
 	# d = {'Michael': 95, 'Bob': 75, 'Tracy': 85,'key': value}
 	# d['key']
 	# 要避免key不存在的错误，有两种办法，
 		# 一是通过in判断key是否存在：
 			'Bob' in d
 		# 二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：
 			d.get('key' ,value)
 		# 要删除一个key，用pop(key)方法，对应的value也会从dict中删除：
 			d.pop('key')

	# 和list比较，dict有以下几个特点：

	# 	查找和插入的速度极快，不会随着key的增加而变慢；
	# 	需要占用大量的内存，内存浪费多。

	# 而list相反：

	# 	查找和插入的时间随着元素的增加而增加；
	# 	占用空间小，浪费内存很少。

	# dict是用空间来换取时间的一种方法

set
	# set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key
	# 要创建一个set，需要提供一个list作为输入集合：
		# s = set([1, 2, 3])
		# s
		# {1, 2, 3}

	# 重复元素在set中自动被过滤：
	# 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果
	# 删除元素remove(key)

	# set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：
		s1 = set([1, 2, 3])
		s2 = set([2, 3, 4])
		交集 s1 & s2
		并集 s1 | s2
		set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，
		因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”