#!usr/bin/python
正则表达式
	\d可以匹配一个数字
	\w可以匹配一个字母或数字
	.可以匹配任意字符
		'py.'可以匹配'pyc'、'pyo'、'py!'
	\d{3}表示匹配3个数字，例如'010'
	\s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配' '，' '等；
	\d{3,8}表示3-8个数字，例如'1234567'。
	A|B可以匹配A或B，所以(P|p)ython可以匹配'Python'或者'python'。
	^表示行的开头，^\d表示必须以数字开头。
	$表示行的结束，\d$表示必须以数字结束。

re模块
	Python提供re模块，包含所有正则表达式的功能
	# Python的字符串本身也用\转义
	s = 'ABC\\-001' # Python的字符串
	# 对应的正则表达式字符串变成：
	# 'ABC\-001'

	使用python的r前缀
	s = r'ABC\-001' # Python的字符串
	# 对应的正则表达式字符串不变：
	# 'ABC\-001'

	import re
	>>> re.match(r'^\d{3}\-\d{3,8}$', '010-12345')#
	<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
	>>> re.match(r'^\d{3}\-\d{3,8}$', '010.12345')

	match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None
	#常见的判断方法
	test = '用户输入的字符串'
	if re.match(r'正则表达式', test):
	    print('ok')
	else:
	    print('failed')

切分字符串
	>>> 'a b    c'.split(' ')	#无法识别连续的空格
	['a', 'b', '', '', '', 'c']
	>>> re.split(r'\s+', 'a b     c')	#无论多少个空格都可以正常分割
	['a', 'b', 'c']
	>>> re.split(r'[\s,]+', 'a,b c    d')	#加入,试试
	['a', 'b', 'c', 'd']
	>>> re.split(r'[\s,]+', 'a,b   ;; c d')
	['a', 'b', ';;', 'c', 'd']
	>>> re.split(r'[\s,\;]+', 'a,b   ;; c d')	#再加入;试试
	['a', 'b', 'c', 'd']

分组
	()表示的就是要提取的分组（Group）
	#^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：
	>>> m =re.match(r'^(\d{3})-(\d{3,8})$', '010-45657000')
	>>> m
	<_sre.SRE_Match object; span=(0, 12), match='010-45657000'>
	>>> m.group(0)	#group(0)永远是原始字符串
	'010-45657000'
	>>> m.group(1)	#group(1)、group(2)……表示第1、2、……个子串
	'010'
	>>> m.group(2)
	'45657000'

	>>> t = '21:42:40'
	>>> m =  m = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)
	>>> m.groups()
	('21', '42', '40')

	# 这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：
	'^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$'

贪婪匹配
	正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符
	#匹配出数字后面的0：
	>>> re.match(r'^(\d+)(0*)$', '102030002010200100').groups()	#由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。
	('102030002010200100', '')

	>>> re.match(r'^(\d+?)(0*)$', '102030002010200100').groups()	#?就可以让\d+采用非贪婪匹配：
	('1020300020102001', '00')

编译
	当我们在Python中使用正则表达式时，re模块内部会干两件事情：
	编译正则表达式，如果正则表达式的字符串本身不合法，会报错；
	用编译后的正则表达式去匹配字符串。	

	# 如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：
	>>> import re
	# 编译:
	>>> re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')	#座机电话
	# 使用：
	>>> re_telephone.match('010-12345').groups()
	('010', '12345')
	>>> re_telephone.match('010-8086').groups()
	('010', '8086')
	编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。


常用内建模块
	Python之所以自称“batteries included”，就是因为内置了许多非常有用的模块，无需额外安装和配置，即可直接使用。
	
	^datetime^
		datetime是Python处理日期和时间的标准库
	^collections^
		collections是Python内建的一个集合模块，提供了许多有用的集合类
	^base64^
		Base64是一种用64个字符来表示任意二进制数据的方法。
	^struct^
		准确地讲，Python没有专门处理字节的数据类型。但由于b'str'可以表示字节，所以，字节数组＝二进制str。而在C语言中，我们可以很方便地用struct、union来处理字节，以及字节和int，float的转换。
	^hashlib^
		Python的hashlib提供了常见的摘要算法，如MD5，SHA1等等。
	^hmac^
		通过哈希算法，我们可以验证一段数据是否有效，方法就是对比该数据的哈希值
	^itertools^
		Python的内建模块itertools提供了非常有用的用于操作迭代对象的函数。
	^contextlib^
		文件操作库
	^urllib^
		urllib提供了一系列用于操作URL的功能。
	^XML^
		XML虽然比JSON复杂，在Web中应用也不如以前多了，不过仍有很多地方在用，所以，有必要了解如何操作XML。
	^HTMLParser^
		Python提供了HTMLParser来非常方便地解析HTML，